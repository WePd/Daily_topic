<!--
 * @Author: WePD
 * @Date: 2021-12-30 09:06:08
-->

### 渲染控制

#### render 的作用

render 的作用是在根据更新得到新的状态之后，通过 React.createElement,替换成新的状态，得到新的 react.element 对象。新的对象上有新的 props，至此，render 结束

#### React 控制渲染的方法

主要有两种方式：

- 从父组件直接阻断子组件的渲染，例如很经典的 memo,缓存 element 对象
- 组件从自身来控制是否 render，例如 pureComponent, shouldComponentUpDate

1. 缓存 element 对象
   主要用于一种情况，父组件 render, 子组件是否也需要 render，若是没有必要 render,那就需要阻断子组件的渲染

```js
//
function Children({number}){
	console.log("子组件渲染")
	return <div>我是子组件，{number}</div>
}

export default class Index extends Component{
	const [numA, setNumA] = useState(0)
	const [numB, setNumB] = useState(0)

	return (
		<div>
		//这种情况下点就numB子组件也会跟着跟新，这种情况不是我们期望的。
		//我们只需要早numA变化的时候子组件跟新，跟numB没有关系。
			<Children num={numA}/>
		//做出如下修改当然这个地方也可以使用useCallback
			{useMemo(（）=> <Children number={numberA} />, [numberA])}
			<button onClick={() => setNumA(numA + 1)}>改变numA</button>
			<button onClick={() => setNumB(numB + 1)}>改变numB</button>
		</div>
	)
}
```

1.1 useMemo 用法：

> const cacheSomething = useMemo(create,deps)

- create：第一个参数为一个函数，函数的返回值作为缓存值，如上 demo 中把 Children 对应的 element 对象，缓存起来。
- deps： 第二个参数为一个数组，存放当前 useMemo 的依赖项，在函数组件下一次执行的时候，会对比 deps 依赖项里面的状态，是否有改变，如果有改变重新执行 create ，得到新的缓存值。
- cacheSomething：返回值，执行 create 的返回值。如果 deps 中有依赖项改变，返回的重新执行 create 产生的值，否则取上一次缓存值。

  1.2 useMemo 原理
  useMemo 会记录上一次执行 create 的返回值，并把它绑定在函数组件对应的 fiber 对象上，只要组件不销毁，缓存值就一直存在，但是 deps 中如果有一项改变，就会重新执行 create ，返回值作为新的值记录到 fiber 对象上
  1.3 element 的缓存，实现了控制子组件不必要的渲染，究其原理是什么呢？
  每次执行 render 本质上 createElement 会产生一个新的 props，这个 props 将作为对应 fiber 的 pendingProps ，在此 fiber 更新调和阶段，React 会对比 fiber 上老 oldProps 和新的 newProp （ pendingProps ）是否相等，如果相等函数组件就会放弃子组件的调和更新，从而子组件不会重新渲染；如果上述把 element 对象缓存起来，上面 props 也就和 fiber 上 oldProps 指向相同的内存空间，也就是相等，从而跳过了本次更新。

2. PurComponent
   纯组件是一种发自组件自身的渲染优化策略，当开发类组件选择继承 purcomponent，就意味着要遵循它的渲染规则，也就是浅比较 state 和 props 是否相等，若不等才会渲染

- 对于 props,purcomponent 会比较 props 是否发生变化，若发生变化才重新渲染
- 对于 state 同样也是会比较
- 浅比较只会比较基础数据类型，对于引用类型，每次都需要重新建一个对象才可以保持变化。
  2.1 purcomponent 原理及其浅比较原则

浅比较规则：

    - 第一步:直接比较新老 props 或者 state 是否相等，如果相等那么就不更新组件
    - 第二步： 判断新老 state 或者 props ，有不是对象，或者为 null 的，那么直接返回 false ，更新组件。
    - 第三步： 通过 Object.keys 将新老 props 或者 state 的属性名 key 变成数组，判断数组的长度是否相等，如果不相等，证明有属性的减少或者增加，那么更新组件
    - 第四步： 遍历老 props 或者老 state ，判断对应的新 props 或新 state ，有没有与之对应并且相等的（这个相等是浅比较），如果有一个不对应或者不相等，那么直 接返回 false ，更新组件。

2.2 purcomponent 注意事项 - 避免使用箭头函数：不要给是 purcomponent 子组件绑定箭头函数，因为父组件每一次 render,若是箭头函数绑定的话，都会重新生成一个箭头函数，浅比较会认为是新的 state 或者 props,就会重新渲染一次 - PureComponent 的父组件是函数组件的情况，绑定函数要用 useCallback 或者 useMemo 处理

```js
export default function () {
	const callback = React.useCallback(function handerCallback() {}, [])
	return <Index callback={callback} />
}
```

    - useCallback 第一个参数就是缓存的内容，useMemo 需要执行第一个函数，返回值为缓存的内容，比起 useCallback ， useMemo 更像是缓存了一段逻辑，或者说执行这		段逻辑获取的结果。

3. shouldComponentUpDate

