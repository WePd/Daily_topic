### 1. 类型别名中的泛型相当于一个代带参的函数
```js
type  Factory<T> = T | string | numbert

相当于

function  Factory(T){
  return [T, string, number]
}
```

### 2. eg
```js
type  Stringify<T> = {
  [k in keyof T] : string
}


type Clone<T> = {
  [k in keyof T]: T[k]
}
```


```js
type Particl<T> = {
  [k in keyof T]?: T[k]
}

interface Ifoo {
  prop1: string,
  prop2: number,
  prop3: boolean,
  prop4: () => void
}


type ParticlIfoo = Particl<Ifoo>


```

### 3. 泛型默认值

```js
type isTrue<T = boolean> = T | string | number

``直接调用``
const check: isTrue = false


```
### 4. 泛型约束
```js
使用``extends``来约束传入的泛型参数必须满足要求

type ResStatus<ResCode extends number> = ResCode extends 10000 | 10001 | 10002
  ? 'success'
  : 'failure';

type res1 = ResStatus<10000> // success
type res1 = ResStatus<10003> // failure


pe test<Type, Name, Prop1, Prop2> = Name extends Type ? Prop1 : Prop2

type res1 = test<string, 'lqy', 'Love', 'Hate'>

```

### 4. 对象中的泛型
```js

```
