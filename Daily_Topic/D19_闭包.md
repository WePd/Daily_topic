### 闭包

闭包是指引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。

因为内部函数引用了这个变量，则这个变量就不会被销毁。

第一次调用函数会发生什么？

在调用一个函数的时候，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止

函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。但是，有了闭包就不一样了。

在一个函数内部定义的函数会把包含函数的活动对象添加到自己的作用域中。个人理解，也就是说在一个函数内部定义得函数会把它引用外部函数的变量添加到自己的作用域链中。

```js
	function fn1() {
		let a = 1;
		function fn2() {
			a++
			console.log(a);
		}
		fn2()
	}
	fn1() // 2
//这样就会有一个后果那就是在fn1()执行完毕之后，它的作用域链会被销毁，但是变量a并不能被销毁，一直到匿名函数被销毁后才会被销毁。
```

因为闭包会保留内部函数的作用域，所以会比其他函数更占用内存，过度使用闭包可能会导致内存过度的占用。

```js
window.id = 'lqy'
	let message = {
		id: 'wpd',
		getId() {
			return function () {
				return this.id
			}
		}
	}
	console.log(message.getId()()); //lqy
```



每个函数在被调用的时候都会自动创建两个特殊变量： this和arguments。内部函数永远不能直接访问外部函数的两个变量。但是，我们可以把this保存到闭包可以访问的另一个变量中，则是可以的。

```js
window.id = 'lqy'
	let message = {
		id: 'wpd',
		getId() {
			let _this = this
			return function () {
				return _this.id
			}
		}
	}
	console.log(message.getId()()); //wpq
```

